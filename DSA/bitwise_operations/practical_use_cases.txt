Practical Use Cases & "Tricks"

  Now that you understand the operators, we can combine them to perform useful manipulations. In interviews, you're often expected to manipulate individual bits
  within a number. The most common tasks are getting, setting, clearing, and toggling a specific bit.

  These operations are fundamental and form the basis of many advanced bitwise algorithms. The key to all of them is creating a "mask". A mask is a specially
  crafted integer that we use with bitwise operators to isolate and change the specific bit we care about.

  We will refer to the bit position as i, starting from 0 for the rightmost bit.

  The Mask: 1 << i

  The mask we need is almost always created by taking the number 1 and shifting it i positions to the left. This creates a number that is all zeros, except for a
  single 1 at the i-th position.

   * If i = 0, mask is 1 << 0 -> 0001
   * If i = 2, mask is 1 << 2 -> 0100
   * If i = 5, mask is 1 << 5 -> 100000

  Let's see how to use this mask. Let's use the number n = 13 (binary 1101) as our example.

  1. Getting the i-th Bit

  This means checking if the bit at position i is a 1 or a 0.

   * Technique: Create the mask and AND it with the number. If the result is non-zero, the bit was 1. If the result is zero, the bit was 0.
      is_set = (n & (1 << i)) != 0

   * Why it works: The mask (1 << i) has a 1 only at position i. When you AND it with your number, all other bits are automatically zeroed out (x & 0 = 0). The only
     bit that can possibly survive is the i-th bit. It will be 1 only if the i-th bit in the original number was also 1 (1 & 1 = 1).

   * Example: Get the 3rd bit of 13 (1101). Here, i = 3.
       * Mask: 1 << 3 -> 1000
       * Operation: 1101 & 1000 -> 1000
       * The result 1000 is non-zero, so the 3rd bit is 1.

  2. Setting the i-th Bit

  This means forcing the bit at position i to become a 1, regardless of its original state.

   * Technique: Create the mask and OR it with the number.
      new_n = n | (1 << i)

   * Why it works: The mask has a 1 only at position i. When you OR it with your number, the i-th bit of the result is guaranteed to be 1 (x | 1 = 1). All other bits
     are unaffected because they are ORed with 0 (x | 0 = x).

   * Example: Set the 2nd bit of 10 (1010). Here, i = 2.
       * Mask: 1 << 2 -> 0100
       * Operation: 1010 | 0100 -> 1110 (which is 14)
       * The 2nd bit is now set.

  3. Clearing the i-th Bit

  This means forcing the bit at position i to become a 0, regardless of its original state.

   * Technique: This is a two-step trick. Create the mask, invert it with ~, and then AND that with the number.
      new_n = n & ~(1 << i)

   * Why it works:
       1. The initial mask 1 << i is ...00100... (a 1 at position i).
       2. Inverting it with ~ creates a mask that is all ones, except for a single 0 at position i: ...11011....
       3. When you AND your number with this inverted mask, the i-th bit is guaranteed to become 0 (x & 0 = 0). All other bits are unaffected because they are ANDed
          with 1 (x & 1 = x).

   * Example: Clear the 3rd bit of 13 (1101). Here, i = 3.
       * Mask: 1 << 3 -> 1000
       * Inverted Mask: ~1000 -> ...11110111
       * Operation: 1101 & ...0111 -> 0101 (which is 5)
       * The 3rd bit is now cleared.

  4. Toggling the i-th Bit

  This means flipping the bit at position i (0 becomes 1, 1 becomes 0).

   * Technique: Create the mask and XOR it with the number.
      new_n = n ^ (1 << i)

   * Why it works: The XOR operator flips a bit if it's compared with 1 (0 ^ 1 = 1; 1 ^ 1 = 0). It leaves a bit unchanged if it's compared with 0 (x ^ 0 = x). The
     mask provides the 1 exactly where we need it and 0s everywhere else.

   * Example: Toggle the 1st bit of 13 (1101). Here, i = 1.
       * Mask: 1 << 1 -> 0010
       * Operation: 1101 ^ 0010 -> 1111 (which is 15)
       * The 1st bit has been flipped from 0 to 1.

  ---